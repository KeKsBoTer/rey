#version 450
#define MIN_DISTANCE 0.001
#define PI  3.14159265359
#define PI2 6.28318530717

layout(local_size_x = 64) in;

layout(std430, set=0, binding=0) buffer SrcBuffer {
    float srcVertices[];
};

layout(set = 0, binding = 1, rgba8) writeonly uniform image2D dstImage;

layout(set=1, binding=0) 
uniform Uniforms {
    mat4 u_view_proj;
};

float seed = 0.0;
vec2 UV = vec2(0.0);


// Helper functions.
float random() {
	return fract(sin(dot(UV, vec2(12.9898, 78.233)) + seed++) * 43758.5453);
}

vec3 randomUnitVector() {
	float theta = random() * PI2;
    float z = random() * 2.0 - 1.0;
    float a = sqrt(1.0 - z * z);
    vec3 vector = vec3(a * cos(theta), a * sin(theta), z);
    return vector * sqrt(random());
}

struct Ray{
    vec3 orig;
    vec3 dir;
};

Ray new_ray(vec3 orig, vec3 dir){
    return Ray(orig,normalize(dir));
}

struct Intersection{
    vec3 pos;
    vec3 normal;
    vec3 color;
    float lambda;
};


struct Camera{
    float focal_length;
    float ratio;
};

Ray cast_ray_from_camera(Camera c,vec2 uv){
    vec3 ray = vec3((uv.x-0.5)*c.ratio,-(uv.y-0.5),1);
    ray = normalize(mat3(u_view_proj) * ray);
    return Ray(
        u_view_proj[3].xyz,
        normalize(mat3(u_view_proj) * ray)
    );
}

struct Sphere{
    float radius;
    vec3 center;
    vec3 color;
};


float sphere_distance(Sphere s, Ray ray){
    vec3 d = ray.orig - s.center;
    float vd = dot(ray.dir,d);

    float dd = dot(d,d); // length squared 

    float r = s.radius;

    float a = vd * vd - dd + r * r;
    if(a<=0.){
        return -1;
    }    
    float ss = sqrt(a);
    float l1 = -vd + ss;
    float l2 = -vd - ss;

    if (l2 > MIN_DISTANCE){
        return l2;
    } else if (l1 > MIN_DISTANCE){
        return l1;
    } else {
        return -1;
    }
}

Intersection sphere_intersection(Sphere s, Ray ray, float lambda){
    vec3 intersect = ray.orig + lambda * ray.dir;
    vec3 normal = (intersect - s.center) / s.radius;

    return Intersection(
        intersect,
        normal,
        s.color,
        lambda
    );
}

struct Ground{
    float y;
    vec3 color;
};

float ground_distance(Ground g, Ray ray){
    float l = (g.y - ray.orig.y) / ray.dir.y;
    if(l < MIN_DISTANCE) {
        return -1;
    }else{
        return l;
    }
}

Intersection ground_intersection(Ground g, Ray ray, float lambda){
    return Intersection(
        ray.orig+ray.dir*lambda,
        vec3(0,1,0),
        g.color,
        lambda
    );
}

bool hitScene(Ray ray, inout Intersection i){
    float closest = 1.0 / 0.0; // aka. infinity
    bool hitAny = false;

    Sphere s = Sphere(1,vec3(0,0,10),vec3(1,0,0));  

    Ground g = Ground(-1,vec3(0,1,0));

    float s_lambda = sphere_distance(s,ray);
    float g_lambda = ground_distance(g,ray);

    if(s_lambda >= 0){
        i = sphere_intersection(s,ray,s_lambda);
        closest = i.lambda;
        hitAny = true;
    }
    if(g_lambda >= 0 && closest > g_lambda){
        i = ground_intersection(g,ray,g_lambda);
        hitAny = true;
    }
    return hitAny;
}


void main() {
    vec2 size = vec2(gl_NumWorkGroups.xy);
    vec2 xy = vec2(gl_GlobalInvocationID.xy);

    seed = float(gl_GlobalInvocationID.x)/float(gl_GlobalInvocationID.y+1) + float(gl_LocalInvocationID.x)/float(gl_LocalInvocationID.y+1);

    vec3 sun_dir = randomUnitVector();


    Camera c = Camera(1,size.x/size.y);

    Ray ray = cast_ray_from_camera(c,xy/size);

    vec4 colorOut = vec4(.5,.5,1,1);
    
    Intersection i;
    if(hitScene(ray,i)){
        colorOut.rgb = i.color;
    }

    imageStore(dstImage, ivec2(gl_GlobalInvocationID.xy), colorOut);//vec4((ray.dir+1)/2,1));
}